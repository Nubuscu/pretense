// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"nubuscu/pretense/ent/album"
	"nubuscu/pretense/ent/artist"
	"nubuscu/pretense/ent/predicate"
	"nubuscu/pretense/ent/review"
	"nubuscu/pretense/ent/tag"
	"nubuscu/pretense/ent/topic"
	"sync"
	"time"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAlbum  = "Album"
	TypeArtist = "Artist"
	TypeReview = "Review"
	TypeTag    = "Tag"
	TypeTopic  = "Topic"
)

// AlbumMutation represents an operation that mutates the Album nodes in the graph.
type AlbumMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	meta_labels        *[]string
	appendmeta_labels  []string
	spotify_url        *string
	name               *string
	clearedFields      map[string]struct{}
	by                 map[int]struct{}
	removedby          map[int]struct{}
	clearedby          bool
	included_in        map[int]struct{}
	removedincluded_in map[int]struct{}
	clearedincluded_in bool
	tagged_with        map[int]struct{}
	removedtagged_with map[int]struct{}
	clearedtagged_with bool
	done               bool
	oldValue           func(context.Context) (*Album, error)
	predicates         []predicate.Album
}

var _ ent.Mutation = (*AlbumMutation)(nil)

// albumOption allows management of the mutation configuration using functional options.
type albumOption func(*AlbumMutation)

// newAlbumMutation creates new mutation for the Album entity.
func newAlbumMutation(c config, op Op, opts ...albumOption) *AlbumMutation {
	m := &AlbumMutation{
		config:        c,
		op:            op,
		typ:           TypeAlbum,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlbumID sets the ID field of the mutation.
func withAlbumID(id int) albumOption {
	return func(m *AlbumMutation) {
		var (
			err   error
			once  sync.Once
			value *Album
		)
		m.oldValue = func(ctx context.Context) (*Album, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Album.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlbum sets the old Album of the mutation.
func withAlbum(node *Album) albumOption {
	return func(m *AlbumMutation) {
		m.oldValue = func(context.Context) (*Album, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlbumMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlbumMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlbumMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlbumMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Album.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AlbumMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AlbumMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AlbumMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AlbumMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AlbumMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AlbumMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetMetaLabels sets the "meta_labels" field.
func (m *AlbumMutation) SetMetaLabels(s []string) {
	m.meta_labels = &s
	m.appendmeta_labels = nil
}

// MetaLabels returns the value of the "meta_labels" field in the mutation.
func (m *AlbumMutation) MetaLabels() (r []string, exists bool) {
	v := m.meta_labels
	if v == nil {
		return
	}
	return *v, true
}

// OldMetaLabels returns the old "meta_labels" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldMetaLabels(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetaLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetaLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetaLabels: %w", err)
	}
	return oldValue.MetaLabels, nil
}

// AppendMetaLabels adds s to the "meta_labels" field.
func (m *AlbumMutation) AppendMetaLabels(s []string) {
	m.appendmeta_labels = append(m.appendmeta_labels, s...)
}

// AppendedMetaLabels returns the list of values that were appended to the "meta_labels" field in this mutation.
func (m *AlbumMutation) AppendedMetaLabels() ([]string, bool) {
	if len(m.appendmeta_labels) == 0 {
		return nil, false
	}
	return m.appendmeta_labels, true
}

// ResetMetaLabels resets all changes to the "meta_labels" field.
func (m *AlbumMutation) ResetMetaLabels() {
	m.meta_labels = nil
	m.appendmeta_labels = nil
}

// SetSpotifyURL sets the "spotify_url" field.
func (m *AlbumMutation) SetSpotifyURL(s string) {
	m.spotify_url = &s
}

// SpotifyURL returns the value of the "spotify_url" field in the mutation.
func (m *AlbumMutation) SpotifyURL() (r string, exists bool) {
	v := m.spotify_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSpotifyURL returns the old "spotify_url" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldSpotifyURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpotifyURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpotifyURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpotifyURL: %w", err)
	}
	return oldValue.SpotifyURL, nil
}

// ResetSpotifyURL resets all changes to the "spotify_url" field.
func (m *AlbumMutation) ResetSpotifyURL() {
	m.spotify_url = nil
}

// SetName sets the "name" field.
func (m *AlbumMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AlbumMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AlbumMutation) ResetName() {
	m.name = nil
}

// AddByIDs adds the "by" edge to the Artist entity by ids.
func (m *AlbumMutation) AddByIDs(ids ...int) {
	if m.by == nil {
		m.by = make(map[int]struct{})
	}
	for i := range ids {
		m.by[ids[i]] = struct{}{}
	}
}

// ClearBy clears the "by" edge to the Artist entity.
func (m *AlbumMutation) ClearBy() {
	m.clearedby = true
}

// ByCleared reports if the "by" edge to the Artist entity was cleared.
func (m *AlbumMutation) ByCleared() bool {
	return m.clearedby
}

// RemoveByIDs removes the "by" edge to the Artist entity by IDs.
func (m *AlbumMutation) RemoveByIDs(ids ...int) {
	if m.removedby == nil {
		m.removedby = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.by, ids[i])
		m.removedby[ids[i]] = struct{}{}
	}
}

// RemovedBy returns the removed IDs of the "by" edge to the Artist entity.
func (m *AlbumMutation) RemovedByIDs() (ids []int) {
	for id := range m.removedby {
		ids = append(ids, id)
	}
	return
}

// ByIDs returns the "by" edge IDs in the mutation.
func (m *AlbumMutation) ByIDs() (ids []int) {
	for id := range m.by {
		ids = append(ids, id)
	}
	return
}

// ResetBy resets all changes to the "by" edge.
func (m *AlbumMutation) ResetBy() {
	m.by = nil
	m.clearedby = false
	m.removedby = nil
}

// AddIncludedInIDs adds the "included_in" edge to the Topic entity by ids.
func (m *AlbumMutation) AddIncludedInIDs(ids ...int) {
	if m.included_in == nil {
		m.included_in = make(map[int]struct{})
	}
	for i := range ids {
		m.included_in[ids[i]] = struct{}{}
	}
}

// ClearIncludedIn clears the "included_in" edge to the Topic entity.
func (m *AlbumMutation) ClearIncludedIn() {
	m.clearedincluded_in = true
}

// IncludedInCleared reports if the "included_in" edge to the Topic entity was cleared.
func (m *AlbumMutation) IncludedInCleared() bool {
	return m.clearedincluded_in
}

// RemoveIncludedInIDs removes the "included_in" edge to the Topic entity by IDs.
func (m *AlbumMutation) RemoveIncludedInIDs(ids ...int) {
	if m.removedincluded_in == nil {
		m.removedincluded_in = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.included_in, ids[i])
		m.removedincluded_in[ids[i]] = struct{}{}
	}
}

// RemovedIncludedIn returns the removed IDs of the "included_in" edge to the Topic entity.
func (m *AlbumMutation) RemovedIncludedInIDs() (ids []int) {
	for id := range m.removedincluded_in {
		ids = append(ids, id)
	}
	return
}

// IncludedInIDs returns the "included_in" edge IDs in the mutation.
func (m *AlbumMutation) IncludedInIDs() (ids []int) {
	for id := range m.included_in {
		ids = append(ids, id)
	}
	return
}

// ResetIncludedIn resets all changes to the "included_in" edge.
func (m *AlbumMutation) ResetIncludedIn() {
	m.included_in = nil
	m.clearedincluded_in = false
	m.removedincluded_in = nil
}

// AddTaggedWithIDs adds the "tagged_with" edge to the Tag entity by ids.
func (m *AlbumMutation) AddTaggedWithIDs(ids ...int) {
	if m.tagged_with == nil {
		m.tagged_with = make(map[int]struct{})
	}
	for i := range ids {
		m.tagged_with[ids[i]] = struct{}{}
	}
}

// ClearTaggedWith clears the "tagged_with" edge to the Tag entity.
func (m *AlbumMutation) ClearTaggedWith() {
	m.clearedtagged_with = true
}

// TaggedWithCleared reports if the "tagged_with" edge to the Tag entity was cleared.
func (m *AlbumMutation) TaggedWithCleared() bool {
	return m.clearedtagged_with
}

// RemoveTaggedWithIDs removes the "tagged_with" edge to the Tag entity by IDs.
func (m *AlbumMutation) RemoveTaggedWithIDs(ids ...int) {
	if m.removedtagged_with == nil {
		m.removedtagged_with = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tagged_with, ids[i])
		m.removedtagged_with[ids[i]] = struct{}{}
	}
}

// RemovedTaggedWith returns the removed IDs of the "tagged_with" edge to the Tag entity.
func (m *AlbumMutation) RemovedTaggedWithIDs() (ids []int) {
	for id := range m.removedtagged_with {
		ids = append(ids, id)
	}
	return
}

// TaggedWithIDs returns the "tagged_with" edge IDs in the mutation.
func (m *AlbumMutation) TaggedWithIDs() (ids []int) {
	for id := range m.tagged_with {
		ids = append(ids, id)
	}
	return
}

// ResetTaggedWith resets all changes to the "tagged_with" edge.
func (m *AlbumMutation) ResetTaggedWith() {
	m.tagged_with = nil
	m.clearedtagged_with = false
	m.removedtagged_with = nil
}

// Where appends a list predicates to the AlbumMutation builder.
func (m *AlbumMutation) Where(ps ...predicate.Album) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AlbumMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Album).
func (m *AlbumMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlbumMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, album.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, album.FieldUpdatedAt)
	}
	if m.meta_labels != nil {
		fields = append(fields, album.FieldMetaLabels)
	}
	if m.spotify_url != nil {
		fields = append(fields, album.FieldSpotifyURL)
	}
	if m.name != nil {
		fields = append(fields, album.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlbumMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case album.FieldCreatedAt:
		return m.CreatedAt()
	case album.FieldUpdatedAt:
		return m.UpdatedAt()
	case album.FieldMetaLabels:
		return m.MetaLabels()
	case album.FieldSpotifyURL:
		return m.SpotifyURL()
	case album.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlbumMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case album.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case album.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case album.FieldMetaLabels:
		return m.OldMetaLabels(ctx)
	case album.FieldSpotifyURL:
		return m.OldSpotifyURL(ctx)
	case album.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Album field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlbumMutation) SetField(name string, value ent.Value) error {
	switch name {
	case album.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case album.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case album.FieldMetaLabels:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetaLabels(v)
		return nil
	case album.FieldSpotifyURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpotifyURL(v)
		return nil
	case album.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Album field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlbumMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlbumMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlbumMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Album numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlbumMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlbumMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlbumMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Album nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlbumMutation) ResetField(name string) error {
	switch name {
	case album.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case album.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case album.FieldMetaLabels:
		m.ResetMetaLabels()
		return nil
	case album.FieldSpotifyURL:
		m.ResetSpotifyURL()
		return nil
	case album.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Album field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlbumMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.by != nil {
		edges = append(edges, album.EdgeBy)
	}
	if m.included_in != nil {
		edges = append(edges, album.EdgeIncludedIn)
	}
	if m.tagged_with != nil {
		edges = append(edges, album.EdgeTaggedWith)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlbumMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case album.EdgeBy:
		ids := make([]ent.Value, 0, len(m.by))
		for id := range m.by {
			ids = append(ids, id)
		}
		return ids
	case album.EdgeIncludedIn:
		ids := make([]ent.Value, 0, len(m.included_in))
		for id := range m.included_in {
			ids = append(ids, id)
		}
		return ids
	case album.EdgeTaggedWith:
		ids := make([]ent.Value, 0, len(m.tagged_with))
		for id := range m.tagged_with {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlbumMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedby != nil {
		edges = append(edges, album.EdgeBy)
	}
	if m.removedincluded_in != nil {
		edges = append(edges, album.EdgeIncludedIn)
	}
	if m.removedtagged_with != nil {
		edges = append(edges, album.EdgeTaggedWith)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlbumMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case album.EdgeBy:
		ids := make([]ent.Value, 0, len(m.removedby))
		for id := range m.removedby {
			ids = append(ids, id)
		}
		return ids
	case album.EdgeIncludedIn:
		ids := make([]ent.Value, 0, len(m.removedincluded_in))
		for id := range m.removedincluded_in {
			ids = append(ids, id)
		}
		return ids
	case album.EdgeTaggedWith:
		ids := make([]ent.Value, 0, len(m.removedtagged_with))
		for id := range m.removedtagged_with {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlbumMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedby {
		edges = append(edges, album.EdgeBy)
	}
	if m.clearedincluded_in {
		edges = append(edges, album.EdgeIncludedIn)
	}
	if m.clearedtagged_with {
		edges = append(edges, album.EdgeTaggedWith)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlbumMutation) EdgeCleared(name string) bool {
	switch name {
	case album.EdgeBy:
		return m.clearedby
	case album.EdgeIncludedIn:
		return m.clearedincluded_in
	case album.EdgeTaggedWith:
		return m.clearedtagged_with
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlbumMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Album unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlbumMutation) ResetEdge(name string) error {
	switch name {
	case album.EdgeBy:
		m.ResetBy()
		return nil
	case album.EdgeIncludedIn:
		m.ResetIncludedIn()
		return nil
	case album.EdgeTaggedWith:
		m.ResetTaggedWith()
		return nil
	}
	return fmt.Errorf("unknown Album edge %s", name)
}

// ArtistMutation represents an operation that mutates the Artist nodes in the graph.
type ArtistMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	meta_labels        *[]string
	appendmeta_labels  []string
	spotify_url        *string
	name               *string
	clearedFields      map[string]struct{}
	wrote              map[int]struct{}
	removedwrote       map[int]struct{}
	clearedwrote       bool
	tagged_with        map[int]struct{}
	removedtagged_with map[int]struct{}
	clearedtagged_with bool
	done               bool
	oldValue           func(context.Context) (*Artist, error)
	predicates         []predicate.Artist
}

var _ ent.Mutation = (*ArtistMutation)(nil)

// artistOption allows management of the mutation configuration using functional options.
type artistOption func(*ArtistMutation)

// newArtistMutation creates new mutation for the Artist entity.
func newArtistMutation(c config, op Op, opts ...artistOption) *ArtistMutation {
	m := &ArtistMutation{
		config:        c,
		op:            op,
		typ:           TypeArtist,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArtistID sets the ID field of the mutation.
func withArtistID(id int) artistOption {
	return func(m *ArtistMutation) {
		var (
			err   error
			once  sync.Once
			value *Artist
		)
		m.oldValue = func(ctx context.Context) (*Artist, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Artist.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArtist sets the old Artist of the mutation.
func withArtist(node *Artist) artistOption {
	return func(m *ArtistMutation) {
		m.oldValue = func(context.Context) (*Artist, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArtistMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArtistMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArtistMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArtistMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Artist.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ArtistMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ArtistMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Artist entity.
// If the Artist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtistMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ArtistMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ArtistMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ArtistMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Artist entity.
// If the Artist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtistMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ArtistMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetMetaLabels sets the "meta_labels" field.
func (m *ArtistMutation) SetMetaLabels(s []string) {
	m.meta_labels = &s
	m.appendmeta_labels = nil
}

// MetaLabels returns the value of the "meta_labels" field in the mutation.
func (m *ArtistMutation) MetaLabels() (r []string, exists bool) {
	v := m.meta_labels
	if v == nil {
		return
	}
	return *v, true
}

// OldMetaLabels returns the old "meta_labels" field's value of the Artist entity.
// If the Artist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtistMutation) OldMetaLabels(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetaLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetaLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetaLabels: %w", err)
	}
	return oldValue.MetaLabels, nil
}

// AppendMetaLabels adds s to the "meta_labels" field.
func (m *ArtistMutation) AppendMetaLabels(s []string) {
	m.appendmeta_labels = append(m.appendmeta_labels, s...)
}

// AppendedMetaLabels returns the list of values that were appended to the "meta_labels" field in this mutation.
func (m *ArtistMutation) AppendedMetaLabels() ([]string, bool) {
	if len(m.appendmeta_labels) == 0 {
		return nil, false
	}
	return m.appendmeta_labels, true
}

// ResetMetaLabels resets all changes to the "meta_labels" field.
func (m *ArtistMutation) ResetMetaLabels() {
	m.meta_labels = nil
	m.appendmeta_labels = nil
}

// SetSpotifyURL sets the "spotify_url" field.
func (m *ArtistMutation) SetSpotifyURL(s string) {
	m.spotify_url = &s
}

// SpotifyURL returns the value of the "spotify_url" field in the mutation.
func (m *ArtistMutation) SpotifyURL() (r string, exists bool) {
	v := m.spotify_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSpotifyURL returns the old "spotify_url" field's value of the Artist entity.
// If the Artist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtistMutation) OldSpotifyURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpotifyURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpotifyURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpotifyURL: %w", err)
	}
	return oldValue.SpotifyURL, nil
}

// ResetSpotifyURL resets all changes to the "spotify_url" field.
func (m *ArtistMutation) ResetSpotifyURL() {
	m.spotify_url = nil
}

// SetName sets the "name" field.
func (m *ArtistMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ArtistMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Artist entity.
// If the Artist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtistMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ArtistMutation) ResetName() {
	m.name = nil
}

// AddWroteIDs adds the "wrote" edge to the Album entity by ids.
func (m *ArtistMutation) AddWroteIDs(ids ...int) {
	if m.wrote == nil {
		m.wrote = make(map[int]struct{})
	}
	for i := range ids {
		m.wrote[ids[i]] = struct{}{}
	}
}

// ClearWrote clears the "wrote" edge to the Album entity.
func (m *ArtistMutation) ClearWrote() {
	m.clearedwrote = true
}

// WroteCleared reports if the "wrote" edge to the Album entity was cleared.
func (m *ArtistMutation) WroteCleared() bool {
	return m.clearedwrote
}

// RemoveWroteIDs removes the "wrote" edge to the Album entity by IDs.
func (m *ArtistMutation) RemoveWroteIDs(ids ...int) {
	if m.removedwrote == nil {
		m.removedwrote = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.wrote, ids[i])
		m.removedwrote[ids[i]] = struct{}{}
	}
}

// RemovedWrote returns the removed IDs of the "wrote" edge to the Album entity.
func (m *ArtistMutation) RemovedWroteIDs() (ids []int) {
	for id := range m.removedwrote {
		ids = append(ids, id)
	}
	return
}

// WroteIDs returns the "wrote" edge IDs in the mutation.
func (m *ArtistMutation) WroteIDs() (ids []int) {
	for id := range m.wrote {
		ids = append(ids, id)
	}
	return
}

// ResetWrote resets all changes to the "wrote" edge.
func (m *ArtistMutation) ResetWrote() {
	m.wrote = nil
	m.clearedwrote = false
	m.removedwrote = nil
}

// AddTaggedWithIDs adds the "tagged_with" edge to the Tag entity by ids.
func (m *ArtistMutation) AddTaggedWithIDs(ids ...int) {
	if m.tagged_with == nil {
		m.tagged_with = make(map[int]struct{})
	}
	for i := range ids {
		m.tagged_with[ids[i]] = struct{}{}
	}
}

// ClearTaggedWith clears the "tagged_with" edge to the Tag entity.
func (m *ArtistMutation) ClearTaggedWith() {
	m.clearedtagged_with = true
}

// TaggedWithCleared reports if the "tagged_with" edge to the Tag entity was cleared.
func (m *ArtistMutation) TaggedWithCleared() bool {
	return m.clearedtagged_with
}

// RemoveTaggedWithIDs removes the "tagged_with" edge to the Tag entity by IDs.
func (m *ArtistMutation) RemoveTaggedWithIDs(ids ...int) {
	if m.removedtagged_with == nil {
		m.removedtagged_with = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tagged_with, ids[i])
		m.removedtagged_with[ids[i]] = struct{}{}
	}
}

// RemovedTaggedWith returns the removed IDs of the "tagged_with" edge to the Tag entity.
func (m *ArtistMutation) RemovedTaggedWithIDs() (ids []int) {
	for id := range m.removedtagged_with {
		ids = append(ids, id)
	}
	return
}

// TaggedWithIDs returns the "tagged_with" edge IDs in the mutation.
func (m *ArtistMutation) TaggedWithIDs() (ids []int) {
	for id := range m.tagged_with {
		ids = append(ids, id)
	}
	return
}

// ResetTaggedWith resets all changes to the "tagged_with" edge.
func (m *ArtistMutation) ResetTaggedWith() {
	m.tagged_with = nil
	m.clearedtagged_with = false
	m.removedtagged_with = nil
}

// Where appends a list predicates to the ArtistMutation builder.
func (m *ArtistMutation) Where(ps ...predicate.Artist) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ArtistMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Artist).
func (m *ArtistMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArtistMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, artist.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, artist.FieldUpdatedAt)
	}
	if m.meta_labels != nil {
		fields = append(fields, artist.FieldMetaLabels)
	}
	if m.spotify_url != nil {
		fields = append(fields, artist.FieldSpotifyURL)
	}
	if m.name != nil {
		fields = append(fields, artist.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArtistMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case artist.FieldCreatedAt:
		return m.CreatedAt()
	case artist.FieldUpdatedAt:
		return m.UpdatedAt()
	case artist.FieldMetaLabels:
		return m.MetaLabels()
	case artist.FieldSpotifyURL:
		return m.SpotifyURL()
	case artist.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArtistMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case artist.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case artist.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case artist.FieldMetaLabels:
		return m.OldMetaLabels(ctx)
	case artist.FieldSpotifyURL:
		return m.OldSpotifyURL(ctx)
	case artist.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Artist field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtistMutation) SetField(name string, value ent.Value) error {
	switch name {
	case artist.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case artist.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case artist.FieldMetaLabels:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetaLabels(v)
		return nil
	case artist.FieldSpotifyURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpotifyURL(v)
		return nil
	case artist.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Artist field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArtistMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArtistMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtistMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Artist numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArtistMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArtistMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArtistMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Artist nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArtistMutation) ResetField(name string) error {
	switch name {
	case artist.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case artist.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case artist.FieldMetaLabels:
		m.ResetMetaLabels()
		return nil
	case artist.FieldSpotifyURL:
		m.ResetSpotifyURL()
		return nil
	case artist.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Artist field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArtistMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.wrote != nil {
		edges = append(edges, artist.EdgeWrote)
	}
	if m.tagged_with != nil {
		edges = append(edges, artist.EdgeTaggedWith)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArtistMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case artist.EdgeWrote:
		ids := make([]ent.Value, 0, len(m.wrote))
		for id := range m.wrote {
			ids = append(ids, id)
		}
		return ids
	case artist.EdgeTaggedWith:
		ids := make([]ent.Value, 0, len(m.tagged_with))
		for id := range m.tagged_with {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArtistMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedwrote != nil {
		edges = append(edges, artist.EdgeWrote)
	}
	if m.removedtagged_with != nil {
		edges = append(edges, artist.EdgeTaggedWith)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArtistMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case artist.EdgeWrote:
		ids := make([]ent.Value, 0, len(m.removedwrote))
		for id := range m.removedwrote {
			ids = append(ids, id)
		}
		return ids
	case artist.EdgeTaggedWith:
		ids := make([]ent.Value, 0, len(m.removedtagged_with))
		for id := range m.removedtagged_with {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArtistMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedwrote {
		edges = append(edges, artist.EdgeWrote)
	}
	if m.clearedtagged_with {
		edges = append(edges, artist.EdgeTaggedWith)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArtistMutation) EdgeCleared(name string) bool {
	switch name {
	case artist.EdgeWrote:
		return m.clearedwrote
	case artist.EdgeTaggedWith:
		return m.clearedtagged_with
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArtistMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Artist unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArtistMutation) ResetEdge(name string) error {
	switch name {
	case artist.EdgeWrote:
		m.ResetWrote()
		return nil
	case artist.EdgeTaggedWith:
		m.ResetTaggedWith()
		return nil
	}
	return fmt.Errorf("unknown Artist edge %s", name)
}

// ReviewMutation represents an operation that mutates the Review nodes in the graph.
type ReviewMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	meta_labels        *[]string
	appendmeta_labels  []string
	name               *string
	body               *string
	clearedFields      map[string]struct{}
	reviews            map[int]struct{}
	removedreviews     map[int]struct{}
	clearedreviews     bool
	tagged_with        map[int]struct{}
	removedtagged_with map[int]struct{}
	clearedtagged_with bool
	done               bool
	oldValue           func(context.Context) (*Review, error)
	predicates         []predicate.Review
}

var _ ent.Mutation = (*ReviewMutation)(nil)

// reviewOption allows management of the mutation configuration using functional options.
type reviewOption func(*ReviewMutation)

// newReviewMutation creates new mutation for the Review entity.
func newReviewMutation(c config, op Op, opts ...reviewOption) *ReviewMutation {
	m := &ReviewMutation{
		config:        c,
		op:            op,
		typ:           TypeReview,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReviewID sets the ID field of the mutation.
func withReviewID(id int) reviewOption {
	return func(m *ReviewMutation) {
		var (
			err   error
			once  sync.Once
			value *Review
		)
		m.oldValue = func(ctx context.Context) (*Review, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Review.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReview sets the old Review of the mutation.
func withReview(node *Review) reviewOption {
	return func(m *ReviewMutation) {
		m.oldValue = func(context.Context) (*Review, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReviewMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReviewMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReviewMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReviewMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Review.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ReviewMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ReviewMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ReviewMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ReviewMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ReviewMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ReviewMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetMetaLabels sets the "meta_labels" field.
func (m *ReviewMutation) SetMetaLabels(s []string) {
	m.meta_labels = &s
	m.appendmeta_labels = nil
}

// MetaLabels returns the value of the "meta_labels" field in the mutation.
func (m *ReviewMutation) MetaLabels() (r []string, exists bool) {
	v := m.meta_labels
	if v == nil {
		return
	}
	return *v, true
}

// OldMetaLabels returns the old "meta_labels" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldMetaLabels(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetaLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetaLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetaLabels: %w", err)
	}
	return oldValue.MetaLabels, nil
}

// AppendMetaLabels adds s to the "meta_labels" field.
func (m *ReviewMutation) AppendMetaLabels(s []string) {
	m.appendmeta_labels = append(m.appendmeta_labels, s...)
}

// AppendedMetaLabels returns the list of values that were appended to the "meta_labels" field in this mutation.
func (m *ReviewMutation) AppendedMetaLabels() ([]string, bool) {
	if len(m.appendmeta_labels) == 0 {
		return nil, false
	}
	return m.appendmeta_labels, true
}

// ResetMetaLabels resets all changes to the "meta_labels" field.
func (m *ReviewMutation) ResetMetaLabels() {
	m.meta_labels = nil
	m.appendmeta_labels = nil
}

// SetName sets the "name" field.
func (m *ReviewMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ReviewMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ReviewMutation) ResetName() {
	m.name = nil
}

// SetBody sets the "body" field.
func (m *ReviewMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *ReviewMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ResetBody resets all changes to the "body" field.
func (m *ReviewMutation) ResetBody() {
	m.body = nil
}

// AddReviewIDs adds the "reviews" edge to the Topic entity by ids.
func (m *ReviewMutation) AddReviewIDs(ids ...int) {
	if m.reviews == nil {
		m.reviews = make(map[int]struct{})
	}
	for i := range ids {
		m.reviews[ids[i]] = struct{}{}
	}
}

// ClearReviews clears the "reviews" edge to the Topic entity.
func (m *ReviewMutation) ClearReviews() {
	m.clearedreviews = true
}

// ReviewsCleared reports if the "reviews" edge to the Topic entity was cleared.
func (m *ReviewMutation) ReviewsCleared() bool {
	return m.clearedreviews
}

// RemoveReviewIDs removes the "reviews" edge to the Topic entity by IDs.
func (m *ReviewMutation) RemoveReviewIDs(ids ...int) {
	if m.removedreviews == nil {
		m.removedreviews = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.reviews, ids[i])
		m.removedreviews[ids[i]] = struct{}{}
	}
}

// RemovedReviews returns the removed IDs of the "reviews" edge to the Topic entity.
func (m *ReviewMutation) RemovedReviewsIDs() (ids []int) {
	for id := range m.removedreviews {
		ids = append(ids, id)
	}
	return
}

// ReviewsIDs returns the "reviews" edge IDs in the mutation.
func (m *ReviewMutation) ReviewsIDs() (ids []int) {
	for id := range m.reviews {
		ids = append(ids, id)
	}
	return
}

// ResetReviews resets all changes to the "reviews" edge.
func (m *ReviewMutation) ResetReviews() {
	m.reviews = nil
	m.clearedreviews = false
	m.removedreviews = nil
}

// AddTaggedWithIDs adds the "tagged_with" edge to the Tag entity by ids.
func (m *ReviewMutation) AddTaggedWithIDs(ids ...int) {
	if m.tagged_with == nil {
		m.tagged_with = make(map[int]struct{})
	}
	for i := range ids {
		m.tagged_with[ids[i]] = struct{}{}
	}
}

// ClearTaggedWith clears the "tagged_with" edge to the Tag entity.
func (m *ReviewMutation) ClearTaggedWith() {
	m.clearedtagged_with = true
}

// TaggedWithCleared reports if the "tagged_with" edge to the Tag entity was cleared.
func (m *ReviewMutation) TaggedWithCleared() bool {
	return m.clearedtagged_with
}

// RemoveTaggedWithIDs removes the "tagged_with" edge to the Tag entity by IDs.
func (m *ReviewMutation) RemoveTaggedWithIDs(ids ...int) {
	if m.removedtagged_with == nil {
		m.removedtagged_with = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tagged_with, ids[i])
		m.removedtagged_with[ids[i]] = struct{}{}
	}
}

// RemovedTaggedWith returns the removed IDs of the "tagged_with" edge to the Tag entity.
func (m *ReviewMutation) RemovedTaggedWithIDs() (ids []int) {
	for id := range m.removedtagged_with {
		ids = append(ids, id)
	}
	return
}

// TaggedWithIDs returns the "tagged_with" edge IDs in the mutation.
func (m *ReviewMutation) TaggedWithIDs() (ids []int) {
	for id := range m.tagged_with {
		ids = append(ids, id)
	}
	return
}

// ResetTaggedWith resets all changes to the "tagged_with" edge.
func (m *ReviewMutation) ResetTaggedWith() {
	m.tagged_with = nil
	m.clearedtagged_with = false
	m.removedtagged_with = nil
}

// Where appends a list predicates to the ReviewMutation builder.
func (m *ReviewMutation) Where(ps ...predicate.Review) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ReviewMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Review).
func (m *ReviewMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReviewMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, review.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, review.FieldUpdatedAt)
	}
	if m.meta_labels != nil {
		fields = append(fields, review.FieldMetaLabels)
	}
	if m.name != nil {
		fields = append(fields, review.FieldName)
	}
	if m.body != nil {
		fields = append(fields, review.FieldBody)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReviewMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case review.FieldCreatedAt:
		return m.CreatedAt()
	case review.FieldUpdatedAt:
		return m.UpdatedAt()
	case review.FieldMetaLabels:
		return m.MetaLabels()
	case review.FieldName:
		return m.Name()
	case review.FieldBody:
		return m.Body()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReviewMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case review.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case review.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case review.FieldMetaLabels:
		return m.OldMetaLabels(ctx)
	case review.FieldName:
		return m.OldName(ctx)
	case review.FieldBody:
		return m.OldBody(ctx)
	}
	return nil, fmt.Errorf("unknown Review field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReviewMutation) SetField(name string, value ent.Value) error {
	switch name {
	case review.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case review.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case review.FieldMetaLabels:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetaLabels(v)
		return nil
	case review.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case review.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	}
	return fmt.Errorf("unknown Review field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReviewMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReviewMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReviewMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Review numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReviewMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReviewMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReviewMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Review nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReviewMutation) ResetField(name string) error {
	switch name {
	case review.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case review.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case review.FieldMetaLabels:
		m.ResetMetaLabels()
		return nil
	case review.FieldName:
		m.ResetName()
		return nil
	case review.FieldBody:
		m.ResetBody()
		return nil
	}
	return fmt.Errorf("unknown Review field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReviewMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.reviews != nil {
		edges = append(edges, review.EdgeReviews)
	}
	if m.tagged_with != nil {
		edges = append(edges, review.EdgeTaggedWith)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReviewMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case review.EdgeReviews:
		ids := make([]ent.Value, 0, len(m.reviews))
		for id := range m.reviews {
			ids = append(ids, id)
		}
		return ids
	case review.EdgeTaggedWith:
		ids := make([]ent.Value, 0, len(m.tagged_with))
		for id := range m.tagged_with {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReviewMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedreviews != nil {
		edges = append(edges, review.EdgeReviews)
	}
	if m.removedtagged_with != nil {
		edges = append(edges, review.EdgeTaggedWith)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReviewMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case review.EdgeReviews:
		ids := make([]ent.Value, 0, len(m.removedreviews))
		for id := range m.removedreviews {
			ids = append(ids, id)
		}
		return ids
	case review.EdgeTaggedWith:
		ids := make([]ent.Value, 0, len(m.removedtagged_with))
		for id := range m.removedtagged_with {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReviewMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedreviews {
		edges = append(edges, review.EdgeReviews)
	}
	if m.clearedtagged_with {
		edges = append(edges, review.EdgeTaggedWith)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReviewMutation) EdgeCleared(name string) bool {
	switch name {
	case review.EdgeReviews:
		return m.clearedreviews
	case review.EdgeTaggedWith:
		return m.clearedtagged_with
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReviewMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Review unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReviewMutation) ResetEdge(name string) error {
	switch name {
	case review.EdgeReviews:
		m.ResetReviews()
		return nil
	case review.EdgeTaggedWith:
		m.ResetTaggedWith()
		return nil
	}
	return fmt.Errorf("unknown Review edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	key                *string
	value              *string
	clearedFields      map[string]struct{}
	tags_album         map[int]struct{}
	removedtags_album  map[int]struct{}
	clearedtags_album  bool
	tags_artist        map[int]struct{}
	removedtags_artist map[int]struct{}
	clearedtags_artist bool
	tags_review        map[int]struct{}
	removedtags_review map[int]struct{}
	clearedtags_review bool
	tags_topic         map[int]struct{}
	removedtags_topic  map[int]struct{}
	clearedtags_topic  bool
	done               bool
	oldValue           func(context.Context) (*Tag, error)
	predicates         []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id int) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKey sets the "key" field.
func (m *TagMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *TagMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *TagMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *TagMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *TagMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *TagMutation) ResetValue() {
	m.value = nil
}

// AddTagsAlbumIDs adds the "tags_album" edge to the Album entity by ids.
func (m *TagMutation) AddTagsAlbumIDs(ids ...int) {
	if m.tags_album == nil {
		m.tags_album = make(map[int]struct{})
	}
	for i := range ids {
		m.tags_album[ids[i]] = struct{}{}
	}
}

// ClearTagsAlbum clears the "tags_album" edge to the Album entity.
func (m *TagMutation) ClearTagsAlbum() {
	m.clearedtags_album = true
}

// TagsAlbumCleared reports if the "tags_album" edge to the Album entity was cleared.
func (m *TagMutation) TagsAlbumCleared() bool {
	return m.clearedtags_album
}

// RemoveTagsAlbumIDs removes the "tags_album" edge to the Album entity by IDs.
func (m *TagMutation) RemoveTagsAlbumIDs(ids ...int) {
	if m.removedtags_album == nil {
		m.removedtags_album = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags_album, ids[i])
		m.removedtags_album[ids[i]] = struct{}{}
	}
}

// RemovedTagsAlbum returns the removed IDs of the "tags_album" edge to the Album entity.
func (m *TagMutation) RemovedTagsAlbumIDs() (ids []int) {
	for id := range m.removedtags_album {
		ids = append(ids, id)
	}
	return
}

// TagsAlbumIDs returns the "tags_album" edge IDs in the mutation.
func (m *TagMutation) TagsAlbumIDs() (ids []int) {
	for id := range m.tags_album {
		ids = append(ids, id)
	}
	return
}

// ResetTagsAlbum resets all changes to the "tags_album" edge.
func (m *TagMutation) ResetTagsAlbum() {
	m.tags_album = nil
	m.clearedtags_album = false
	m.removedtags_album = nil
}

// AddTagsArtistIDs adds the "tags_artist" edge to the Artist entity by ids.
func (m *TagMutation) AddTagsArtistIDs(ids ...int) {
	if m.tags_artist == nil {
		m.tags_artist = make(map[int]struct{})
	}
	for i := range ids {
		m.tags_artist[ids[i]] = struct{}{}
	}
}

// ClearTagsArtist clears the "tags_artist" edge to the Artist entity.
func (m *TagMutation) ClearTagsArtist() {
	m.clearedtags_artist = true
}

// TagsArtistCleared reports if the "tags_artist" edge to the Artist entity was cleared.
func (m *TagMutation) TagsArtistCleared() bool {
	return m.clearedtags_artist
}

// RemoveTagsArtistIDs removes the "tags_artist" edge to the Artist entity by IDs.
func (m *TagMutation) RemoveTagsArtistIDs(ids ...int) {
	if m.removedtags_artist == nil {
		m.removedtags_artist = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags_artist, ids[i])
		m.removedtags_artist[ids[i]] = struct{}{}
	}
}

// RemovedTagsArtist returns the removed IDs of the "tags_artist" edge to the Artist entity.
func (m *TagMutation) RemovedTagsArtistIDs() (ids []int) {
	for id := range m.removedtags_artist {
		ids = append(ids, id)
	}
	return
}

// TagsArtistIDs returns the "tags_artist" edge IDs in the mutation.
func (m *TagMutation) TagsArtistIDs() (ids []int) {
	for id := range m.tags_artist {
		ids = append(ids, id)
	}
	return
}

// ResetTagsArtist resets all changes to the "tags_artist" edge.
func (m *TagMutation) ResetTagsArtist() {
	m.tags_artist = nil
	m.clearedtags_artist = false
	m.removedtags_artist = nil
}

// AddTagsReviewIDs adds the "tags_review" edge to the Review entity by ids.
func (m *TagMutation) AddTagsReviewIDs(ids ...int) {
	if m.tags_review == nil {
		m.tags_review = make(map[int]struct{})
	}
	for i := range ids {
		m.tags_review[ids[i]] = struct{}{}
	}
}

// ClearTagsReview clears the "tags_review" edge to the Review entity.
func (m *TagMutation) ClearTagsReview() {
	m.clearedtags_review = true
}

// TagsReviewCleared reports if the "tags_review" edge to the Review entity was cleared.
func (m *TagMutation) TagsReviewCleared() bool {
	return m.clearedtags_review
}

// RemoveTagsReviewIDs removes the "tags_review" edge to the Review entity by IDs.
func (m *TagMutation) RemoveTagsReviewIDs(ids ...int) {
	if m.removedtags_review == nil {
		m.removedtags_review = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags_review, ids[i])
		m.removedtags_review[ids[i]] = struct{}{}
	}
}

// RemovedTagsReview returns the removed IDs of the "tags_review" edge to the Review entity.
func (m *TagMutation) RemovedTagsReviewIDs() (ids []int) {
	for id := range m.removedtags_review {
		ids = append(ids, id)
	}
	return
}

// TagsReviewIDs returns the "tags_review" edge IDs in the mutation.
func (m *TagMutation) TagsReviewIDs() (ids []int) {
	for id := range m.tags_review {
		ids = append(ids, id)
	}
	return
}

// ResetTagsReview resets all changes to the "tags_review" edge.
func (m *TagMutation) ResetTagsReview() {
	m.tags_review = nil
	m.clearedtags_review = false
	m.removedtags_review = nil
}

// AddTagsTopicIDs adds the "tags_topic" edge to the Topic entity by ids.
func (m *TagMutation) AddTagsTopicIDs(ids ...int) {
	if m.tags_topic == nil {
		m.tags_topic = make(map[int]struct{})
	}
	for i := range ids {
		m.tags_topic[ids[i]] = struct{}{}
	}
}

// ClearTagsTopic clears the "tags_topic" edge to the Topic entity.
func (m *TagMutation) ClearTagsTopic() {
	m.clearedtags_topic = true
}

// TagsTopicCleared reports if the "tags_topic" edge to the Topic entity was cleared.
func (m *TagMutation) TagsTopicCleared() bool {
	return m.clearedtags_topic
}

// RemoveTagsTopicIDs removes the "tags_topic" edge to the Topic entity by IDs.
func (m *TagMutation) RemoveTagsTopicIDs(ids ...int) {
	if m.removedtags_topic == nil {
		m.removedtags_topic = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags_topic, ids[i])
		m.removedtags_topic[ids[i]] = struct{}{}
	}
}

// RemovedTagsTopic returns the removed IDs of the "tags_topic" edge to the Topic entity.
func (m *TagMutation) RemovedTagsTopicIDs() (ids []int) {
	for id := range m.removedtags_topic {
		ids = append(ids, id)
	}
	return
}

// TagsTopicIDs returns the "tags_topic" edge IDs in the mutation.
func (m *TagMutation) TagsTopicIDs() (ids []int) {
	for id := range m.tags_topic {
		ids = append(ids, id)
	}
	return
}

// ResetTagsTopic resets all changes to the "tags_topic" edge.
func (m *TagMutation) ResetTagsTopic() {
	m.tags_topic = nil
	m.clearedtags_topic = false
	m.removedtags_topic = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.key != nil {
		fields = append(fields, tag.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, tag.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldKey:
		return m.Key()
	case tag.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldKey:
		return m.OldKey(ctx)
	case tag.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case tag.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldKey:
		m.ResetKey()
		return nil
	case tag.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tags_album != nil {
		edges = append(edges, tag.EdgeTagsAlbum)
	}
	if m.tags_artist != nil {
		edges = append(edges, tag.EdgeTagsArtist)
	}
	if m.tags_review != nil {
		edges = append(edges, tag.EdgeTagsReview)
	}
	if m.tags_topic != nil {
		edges = append(edges, tag.EdgeTagsTopic)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeTagsAlbum:
		ids := make([]ent.Value, 0, len(m.tags_album))
		for id := range m.tags_album {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeTagsArtist:
		ids := make([]ent.Value, 0, len(m.tags_artist))
		for id := range m.tags_artist {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeTagsReview:
		ids := make([]ent.Value, 0, len(m.tags_review))
		for id := range m.tags_review {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeTagsTopic:
		ids := make([]ent.Value, 0, len(m.tags_topic))
		for id := range m.tags_topic {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedtags_album != nil {
		edges = append(edges, tag.EdgeTagsAlbum)
	}
	if m.removedtags_artist != nil {
		edges = append(edges, tag.EdgeTagsArtist)
	}
	if m.removedtags_review != nil {
		edges = append(edges, tag.EdgeTagsReview)
	}
	if m.removedtags_topic != nil {
		edges = append(edges, tag.EdgeTagsTopic)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeTagsAlbum:
		ids := make([]ent.Value, 0, len(m.removedtags_album))
		for id := range m.removedtags_album {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeTagsArtist:
		ids := make([]ent.Value, 0, len(m.removedtags_artist))
		for id := range m.removedtags_artist {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeTagsReview:
		ids := make([]ent.Value, 0, len(m.removedtags_review))
		for id := range m.removedtags_review {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeTagsTopic:
		ids := make([]ent.Value, 0, len(m.removedtags_topic))
		for id := range m.removedtags_topic {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtags_album {
		edges = append(edges, tag.EdgeTagsAlbum)
	}
	if m.clearedtags_artist {
		edges = append(edges, tag.EdgeTagsArtist)
	}
	if m.clearedtags_review {
		edges = append(edges, tag.EdgeTagsReview)
	}
	if m.clearedtags_topic {
		edges = append(edges, tag.EdgeTagsTopic)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeTagsAlbum:
		return m.clearedtags_album
	case tag.EdgeTagsArtist:
		return m.clearedtags_artist
	case tag.EdgeTagsReview:
		return m.clearedtags_review
	case tag.EdgeTagsTopic:
		return m.clearedtags_topic
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeTagsAlbum:
		m.ResetTagsAlbum()
		return nil
	case tag.EdgeTagsArtist:
		m.ResetTagsArtist()
		return nil
	case tag.EdgeTagsReview:
		m.ResetTagsReview()
		return nil
	case tag.EdgeTagsTopic:
		m.ResetTagsTopic()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// TopicMutation represents an operation that mutates the Topic nodes in the graph.
type TopicMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	meta_labels        *[]string
	appendmeta_labels  []string
	name               *string
	clearedFields      map[string]struct{}
	reviewed_by        map[int]struct{}
	removedreviewed_by map[int]struct{}
	clearedreviewed_by bool
	includes           map[int]struct{}
	removedincludes    map[int]struct{}
	clearedincludes    bool
	tagged_with        map[int]struct{}
	removedtagged_with map[int]struct{}
	clearedtagged_with bool
	done               bool
	oldValue           func(context.Context) (*Topic, error)
	predicates         []predicate.Topic
}

var _ ent.Mutation = (*TopicMutation)(nil)

// topicOption allows management of the mutation configuration using functional options.
type topicOption func(*TopicMutation)

// newTopicMutation creates new mutation for the Topic entity.
func newTopicMutation(c config, op Op, opts ...topicOption) *TopicMutation {
	m := &TopicMutation{
		config:        c,
		op:            op,
		typ:           TypeTopic,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTopicID sets the ID field of the mutation.
func withTopicID(id int) topicOption {
	return func(m *TopicMutation) {
		var (
			err   error
			once  sync.Once
			value *Topic
		)
		m.oldValue = func(ctx context.Context) (*Topic, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Topic.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTopic sets the old Topic of the mutation.
func withTopic(node *Topic) topicOption {
	return func(m *TopicMutation) {
		m.oldValue = func(context.Context) (*Topic, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TopicMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TopicMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TopicMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TopicMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Topic.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TopicMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TopicMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Topic entity.
// If the Topic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TopicMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TopicMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TopicMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Topic entity.
// If the Topic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TopicMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetMetaLabels sets the "meta_labels" field.
func (m *TopicMutation) SetMetaLabels(s []string) {
	m.meta_labels = &s
	m.appendmeta_labels = nil
}

// MetaLabels returns the value of the "meta_labels" field in the mutation.
func (m *TopicMutation) MetaLabels() (r []string, exists bool) {
	v := m.meta_labels
	if v == nil {
		return
	}
	return *v, true
}

// OldMetaLabels returns the old "meta_labels" field's value of the Topic entity.
// If the Topic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicMutation) OldMetaLabels(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetaLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetaLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetaLabels: %w", err)
	}
	return oldValue.MetaLabels, nil
}

// AppendMetaLabels adds s to the "meta_labels" field.
func (m *TopicMutation) AppendMetaLabels(s []string) {
	m.appendmeta_labels = append(m.appendmeta_labels, s...)
}

// AppendedMetaLabels returns the list of values that were appended to the "meta_labels" field in this mutation.
func (m *TopicMutation) AppendedMetaLabels() ([]string, bool) {
	if len(m.appendmeta_labels) == 0 {
		return nil, false
	}
	return m.appendmeta_labels, true
}

// ResetMetaLabels resets all changes to the "meta_labels" field.
func (m *TopicMutation) ResetMetaLabels() {
	m.meta_labels = nil
	m.appendmeta_labels = nil
}

// SetName sets the "name" field.
func (m *TopicMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TopicMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Topic entity.
// If the Topic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TopicMutation) ResetName() {
	m.name = nil
}

// AddReviewedByIDs adds the "reviewed_by" edge to the Review entity by ids.
func (m *TopicMutation) AddReviewedByIDs(ids ...int) {
	if m.reviewed_by == nil {
		m.reviewed_by = make(map[int]struct{})
	}
	for i := range ids {
		m.reviewed_by[ids[i]] = struct{}{}
	}
}

// ClearReviewedBy clears the "reviewed_by" edge to the Review entity.
func (m *TopicMutation) ClearReviewedBy() {
	m.clearedreviewed_by = true
}

// ReviewedByCleared reports if the "reviewed_by" edge to the Review entity was cleared.
func (m *TopicMutation) ReviewedByCleared() bool {
	return m.clearedreviewed_by
}

// RemoveReviewedByIDs removes the "reviewed_by" edge to the Review entity by IDs.
func (m *TopicMutation) RemoveReviewedByIDs(ids ...int) {
	if m.removedreviewed_by == nil {
		m.removedreviewed_by = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.reviewed_by, ids[i])
		m.removedreviewed_by[ids[i]] = struct{}{}
	}
}

// RemovedReviewedBy returns the removed IDs of the "reviewed_by" edge to the Review entity.
func (m *TopicMutation) RemovedReviewedByIDs() (ids []int) {
	for id := range m.removedreviewed_by {
		ids = append(ids, id)
	}
	return
}

// ReviewedByIDs returns the "reviewed_by" edge IDs in the mutation.
func (m *TopicMutation) ReviewedByIDs() (ids []int) {
	for id := range m.reviewed_by {
		ids = append(ids, id)
	}
	return
}

// ResetReviewedBy resets all changes to the "reviewed_by" edge.
func (m *TopicMutation) ResetReviewedBy() {
	m.reviewed_by = nil
	m.clearedreviewed_by = false
	m.removedreviewed_by = nil
}

// AddIncludeIDs adds the "includes" edge to the Album entity by ids.
func (m *TopicMutation) AddIncludeIDs(ids ...int) {
	if m.includes == nil {
		m.includes = make(map[int]struct{})
	}
	for i := range ids {
		m.includes[ids[i]] = struct{}{}
	}
}

// ClearIncludes clears the "includes" edge to the Album entity.
func (m *TopicMutation) ClearIncludes() {
	m.clearedincludes = true
}

// IncludesCleared reports if the "includes" edge to the Album entity was cleared.
func (m *TopicMutation) IncludesCleared() bool {
	return m.clearedincludes
}

// RemoveIncludeIDs removes the "includes" edge to the Album entity by IDs.
func (m *TopicMutation) RemoveIncludeIDs(ids ...int) {
	if m.removedincludes == nil {
		m.removedincludes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.includes, ids[i])
		m.removedincludes[ids[i]] = struct{}{}
	}
}

// RemovedIncludes returns the removed IDs of the "includes" edge to the Album entity.
func (m *TopicMutation) RemovedIncludesIDs() (ids []int) {
	for id := range m.removedincludes {
		ids = append(ids, id)
	}
	return
}

// IncludesIDs returns the "includes" edge IDs in the mutation.
func (m *TopicMutation) IncludesIDs() (ids []int) {
	for id := range m.includes {
		ids = append(ids, id)
	}
	return
}

// ResetIncludes resets all changes to the "includes" edge.
func (m *TopicMutation) ResetIncludes() {
	m.includes = nil
	m.clearedincludes = false
	m.removedincludes = nil
}

// AddTaggedWithIDs adds the "tagged_with" edge to the Tag entity by ids.
func (m *TopicMutation) AddTaggedWithIDs(ids ...int) {
	if m.tagged_with == nil {
		m.tagged_with = make(map[int]struct{})
	}
	for i := range ids {
		m.tagged_with[ids[i]] = struct{}{}
	}
}

// ClearTaggedWith clears the "tagged_with" edge to the Tag entity.
func (m *TopicMutation) ClearTaggedWith() {
	m.clearedtagged_with = true
}

// TaggedWithCleared reports if the "tagged_with" edge to the Tag entity was cleared.
func (m *TopicMutation) TaggedWithCleared() bool {
	return m.clearedtagged_with
}

// RemoveTaggedWithIDs removes the "tagged_with" edge to the Tag entity by IDs.
func (m *TopicMutation) RemoveTaggedWithIDs(ids ...int) {
	if m.removedtagged_with == nil {
		m.removedtagged_with = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tagged_with, ids[i])
		m.removedtagged_with[ids[i]] = struct{}{}
	}
}

// RemovedTaggedWith returns the removed IDs of the "tagged_with" edge to the Tag entity.
func (m *TopicMutation) RemovedTaggedWithIDs() (ids []int) {
	for id := range m.removedtagged_with {
		ids = append(ids, id)
	}
	return
}

// TaggedWithIDs returns the "tagged_with" edge IDs in the mutation.
func (m *TopicMutation) TaggedWithIDs() (ids []int) {
	for id := range m.tagged_with {
		ids = append(ids, id)
	}
	return
}

// ResetTaggedWith resets all changes to the "tagged_with" edge.
func (m *TopicMutation) ResetTaggedWith() {
	m.tagged_with = nil
	m.clearedtagged_with = false
	m.removedtagged_with = nil
}

// Where appends a list predicates to the TopicMutation builder.
func (m *TopicMutation) Where(ps ...predicate.Topic) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TopicMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Topic).
func (m *TopicMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TopicMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, topic.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, topic.FieldUpdatedAt)
	}
	if m.meta_labels != nil {
		fields = append(fields, topic.FieldMetaLabels)
	}
	if m.name != nil {
		fields = append(fields, topic.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TopicMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case topic.FieldCreatedAt:
		return m.CreatedAt()
	case topic.FieldUpdatedAt:
		return m.UpdatedAt()
	case topic.FieldMetaLabels:
		return m.MetaLabels()
	case topic.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TopicMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case topic.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case topic.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case topic.FieldMetaLabels:
		return m.OldMetaLabels(ctx)
	case topic.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Topic field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TopicMutation) SetField(name string, value ent.Value) error {
	switch name {
	case topic.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case topic.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case topic.FieldMetaLabels:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetaLabels(v)
		return nil
	case topic.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Topic field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TopicMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TopicMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TopicMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Topic numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TopicMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TopicMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TopicMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Topic nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TopicMutation) ResetField(name string) error {
	switch name {
	case topic.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case topic.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case topic.FieldMetaLabels:
		m.ResetMetaLabels()
		return nil
	case topic.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Topic field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TopicMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.reviewed_by != nil {
		edges = append(edges, topic.EdgeReviewedBy)
	}
	if m.includes != nil {
		edges = append(edges, topic.EdgeIncludes)
	}
	if m.tagged_with != nil {
		edges = append(edges, topic.EdgeTaggedWith)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TopicMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case topic.EdgeReviewedBy:
		ids := make([]ent.Value, 0, len(m.reviewed_by))
		for id := range m.reviewed_by {
			ids = append(ids, id)
		}
		return ids
	case topic.EdgeIncludes:
		ids := make([]ent.Value, 0, len(m.includes))
		for id := range m.includes {
			ids = append(ids, id)
		}
		return ids
	case topic.EdgeTaggedWith:
		ids := make([]ent.Value, 0, len(m.tagged_with))
		for id := range m.tagged_with {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TopicMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedreviewed_by != nil {
		edges = append(edges, topic.EdgeReviewedBy)
	}
	if m.removedincludes != nil {
		edges = append(edges, topic.EdgeIncludes)
	}
	if m.removedtagged_with != nil {
		edges = append(edges, topic.EdgeTaggedWith)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TopicMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case topic.EdgeReviewedBy:
		ids := make([]ent.Value, 0, len(m.removedreviewed_by))
		for id := range m.removedreviewed_by {
			ids = append(ids, id)
		}
		return ids
	case topic.EdgeIncludes:
		ids := make([]ent.Value, 0, len(m.removedincludes))
		for id := range m.removedincludes {
			ids = append(ids, id)
		}
		return ids
	case topic.EdgeTaggedWith:
		ids := make([]ent.Value, 0, len(m.removedtagged_with))
		for id := range m.removedtagged_with {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TopicMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedreviewed_by {
		edges = append(edges, topic.EdgeReviewedBy)
	}
	if m.clearedincludes {
		edges = append(edges, topic.EdgeIncludes)
	}
	if m.clearedtagged_with {
		edges = append(edges, topic.EdgeTaggedWith)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TopicMutation) EdgeCleared(name string) bool {
	switch name {
	case topic.EdgeReviewedBy:
		return m.clearedreviewed_by
	case topic.EdgeIncludes:
		return m.clearedincludes
	case topic.EdgeTaggedWith:
		return m.clearedtagged_with
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TopicMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Topic unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TopicMutation) ResetEdge(name string) error {
	switch name {
	case topic.EdgeReviewedBy:
		m.ResetReviewedBy()
		return nil
	case topic.EdgeIncludes:
		m.ResetIncludes()
		return nil
	case topic.EdgeTaggedWith:
		m.ResetTaggedWith()
		return nil
	}
	return fmt.Errorf("unknown Topic edge %s", name)
}
